# SPRITES provides simple sprites with a maximal height of 24px
# and arbitrary width. The library aims to render sprites as
# quickly as possible at the expense of some storage overhead, 
# which can be substantial for small sprites.
#
# The low-level data structure are Sprite objects, which hold
# bitmap data for a single sprite with background mask. They
# are initialised with two byte arrays as generated by the
# web editor. Keep in mind that the maximum height of a sprite
# is 24px and that bitmap data need to be zero-padded to full
# bytes if height is not a multiple of eight. There is no
# support for frame animation or keeping track of the position
# of a sprite; use the SpriteObj class for this purpose.
#
# spr = sprites.Sprite(width, height, bitmap, mask)
#  - bitmap and mask must be bytearrays of appropriate size
#    containing bitmap data in the same layout as the display
#
# spr.draw(x0, y0, invert)
#  - draw sprite with top left corner at pixel coordinates (x0, y0)
#  - if invert=True, draw sprite in black on white (with same mask)
#
# A SpriteObj is used to manage a sprite on the screen, with
# automatic linear movement and frame animation. The actual
# bitmap data is provided by Sprite objects, so multiple copies
# of the same sprite can be displayed without memory overhead 
# via different SpriteObj instances that reference the same Sprite.
# Coordinates, movement speed, etc. are floating-point numbers,
# with (10.0, 5.0) located at the centre of pixel (10, 5).
#
# obj = sprites.SpriteObj(frames=[spr1, spr2, ...], ...)
#  - frames provides a list of Sprite objects with bitmap data
#    for all animation frames (possibly just a single one)
#  - further parameters can be passed to initialised the state
#    of the sprite: x, y, vx, vy, fx, fy, ax, ay, frame, visible
#  - see accessor functions below for documentation
#
# obj.move(x, y)
#  - move object to coordinates (x, y), both floating-point
#
# obj.speed(vx, vy)
#  - set movement speed of object to (vx, vy)
#
# obj.accel(ax, ay)
#  - set acceleration of object to (ax, ay) 
#  - vx is increased by ax per second, vy by ay per second
#
# obj.friction(fx, fy)
#  - set friction in x and y direction (can be different)
#  - clamped to non-negative values
#  - vx is reduced by fx * vx per second, vy by fy * vy
#
# obj.frame(n)
#  - display frame n (with n = 0 for first frame)
#  - automatically clamped to available frames
#
# out_x, out_y = obj.onscreen(margin=0.0):
#  - whether sprite is currently in visible screen range
#  - independent of whether obj.visible(True) or not
#  - margin extends screen by specified amount (px) on all sides
#  - returns separate indicators -1/0/1 for x and y ranges
#
# obj.visible(visible)
#  - whether sprite is visible (True) or not (False)
#
# obj.update(dt)
#  - update position of sprite over dt seconds
#
# obj.draw(invert=False)
#  - draw sprite at current position (inverted if invert=True)
#

import thumby
import math
from array import array

class Sprite:
    def __init__(self, width: int, height: int, bitmap: bytearray, mask: bytearray):
        if width < 1:
            raise Exception("width must be >= 1")
        if height < 1 or height > 24:
            raise Exception("height must be between 1px and 24px")
        self.width = width
        self.height = height
        h_bytes = (height + 7) // 8 # number of bytes required for each vertical scanline
        size = h_bytes * width
        if len(bitmap) != size:
            raise Exception(f"not the right amount of bitmap data (expected {size} bytes)")
        if len(mask) != size:
            raise Exception(f"not the right amount of mask data (expected {size} bytes)")
        self.bitmap = array("L", [0] * width)
        self.mask = array("L", [0] * width)
        for x in range(width):
            b_long = m_long = 0 # 32bit integer holding bitmap data for one vertical scanline
            for y in range(h_bytes):
                b_long += bitmap[y * width + x] << (8 * y)
                m_long += mask[y * width + x] << (8 * y)
            self.bitmap[x] = b_long
            self.mask[x] = m_long

    @micropython.viper
    def draw(self, x0: int, y0: int, invert: bool):
        w = int(self.width)
        h = int(self.height)
        if x0 + w <= 0 or x0 >= 72 or y0 + h <= 0 or y0 >= 40:
            return # sprite completely outside screen

        w_start = 0 if x0 >= 0 else 0 - x0     # which vertical scanlines will be rendered
        w_end = w if x0 + w <= 72 else 72 - x0
        
        y_start = y0 // 8 # byte offset on vertical scanline
        h_start = 0 if y_start >= 0 else 0 - y_start # first byte to render
        y_off = y_start if y_start >= 0 else 0
        shift = y0 % 8    #  required bit shift
        h_end = (h + shift + 7) // 8 # last byte to render + 1
        if y_start + h_end > 5:
            h_end = 5 - y_start

        scr = ptr8(thumby.display.display.buffer)
        for dx in range(w_start, w_end):
            sp = x0 + dx + y_off * 72
            b_long = uint(self.bitmap[dx]) << shift
            m_long = uint(self.mask[dx]) << shift
            b_long >>= (8 * h_start)
            m_long >>= (8 * h_start)
            if invert:
                b_long ^= -1
                for b in range(h_start, h_end):
                    scr[sp] |= m_long # operates on lsb
                    scr[sp] &= b_long
                    m_long >>= 8
                    b_long >>= 8
                    sp += 72
            else:
                m_long ^= -1
                for b in range(h_start, h_end):
                    scr[sp] &= m_long # operates on lsb
                    scr[sp] |= b_long
                    m_long >>= 8
                    b_long >>= 8
                    sp += 72


class SpriteObj:
    def __init__(self, frames: list, 
                 x: float = 0.0, y: float = 0.0, vx: float = 0.0, vy: float = 0.0,
                 ax: float = 0.0, ay: float = 0.0, fx: float = 0.0, fy: float = 0.0,
                 frame: int = 0, visible: bool = True):
        self.frames = frames
        self.n_frames = len(frames)
        self.move(x, y)
        self.speed(vx, vy)
        self.accel(ax, ay)
        self.friction(fx, fy)
        self.frame(frame)
        self.visible(visible)
        
    @micropython.native
    def move(self, x: float, y: float):
        self.x = x
        self.y = y
    
    @micropython.native
    def speed(self, vx: float, vy: float):
        self.vx = vx
        self.vy = vy

    @micropython.native
    def accel(self, ax: float, ay: float):
        self.ax = ax
        self.ay = ay
    
    @micropython.native
    def friction(self, fx: float, fy: float):
        self.fx = 0.0 if fx < 0.0 else fx
        self.fy = 0.0 if fy < 0.0 else fy

    @micropython.native
    def frame(self, n: int):
        self.frame = 0 if n < 0 else self.n_frames - 1 if n >= self.n_frames else n

    @micropython.native
    def visible(self, visible: bool):
        self.visible = visible

    @micropython.native
    def onscreen(self, margin=0.0) -> (int, int):
        w = self.frames[self.frame].width
        h = self.frames[self.frame].height
        out_x = -1 if (self.x + w + margin < 0.0) else 1 if (self.x >= 72.0 + margin) else 0
        out_y = -1 if (self.y + h + margin < 0.0) else 1 if (self.y >= 40.0 + margin) else 0
        return out_x, out_y
    
    @micropython.native
    def update(self, dt: float):
        vx = self.vx
        vy = self.vy
        vx += self.ax * dt
        vy += self.ay * dt
        fx = self.fx * dt
        fx = fx if fx <= 1.0 else 1.0 # make sure we don't decelerate past full stop
        fy = self.fy * dt
        fy = fy if fy <= 1.0 else 1.0
        vx *= 1.0 - fx
        vy *= 1.0 - fy
        self.vx = vx
        self.vy = vy
        self.x += self.vx
        self.y += self.vy

    @micropython.native
    def draw(self, invert: bool = False):
        if self.visible:
            x = int(math.floor(self.x + 0.5))
            y = int(math.floor(self.y + 0.5))
            spr = self.frames[self.frame]
            spr.draw(x, y, invert)
