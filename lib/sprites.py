# SPRITES provides simple sprites with a maximal height of 24px
# and arbitrary width. The library aims to render sprites as
# quickly as possible at the expense of some storage overhead, 
# which can be substantial for small sprites. There is also no
# support for frame animation, which will require the user to
# manage a list of Sprite objects for each frame.
#
# The central data structure are Sprite objects, which hold
# bitmap data for a single sprite with background mask. They
# are initialised with two byte arrays as generated by the
# web editor. Keep in mind that the maximum height of a sprite
# is 24px and that bitmap data need to be zero-padded to full
# bytes if height is not a multiple of eight.
#
# spr = sprites.Sprite(width, height, bitmap, mask)
#  - bitmap and mask must be bytearrays of appropriate size
#    containing bitmap data in the same layout as the display
#
# spr.draw(x0, y0, invert)
#  - draw sprite with top left corner at pixel coordinates (x0, y0)
#  - if invert=True, draw sprite in black on white (with same mask)
#


import thumby
import math
from array import array

class Sprite:
    def __init__(self, width: int, height: int, bitmap: bytearray, mask: bytearray):
        if width < 1:
            raise Exception("width must be >= 1")
        if height < 1 or height > 24:
            raise Exception("height must be between 1px and 24px")
        self.width = width
        self.height = height
        h_bytes = (height + 7) // 8 # number of bytes required for each vertical scanline
        size = h_bytes * width
        if len(bitmap) != size:
            raise Exception(f"not the right amount of bitmap data (expected {size} bytes)")
        if len(mask) != size:
            raise Exception(f"not the right amount of mask data (expected {size} bytes)")
        self.bitmap = array("L", [0] * width)
        self.mask = array("L", [0] * width)
        for x in range(width):
            b_long = m_long = 0 # 32bit integer holding bitmap data for one vertical scanline
            for y in range(h_bytes):
                b_long += bitmap[y * width + x] << (8 * y)
                m_long += mask[y * width + x] << (8 * y)
            self.bitmap[x] = b_long
            self.mask[x] = m_long

    @micropython.viper
    def draw(self, x0: int, y0: int, invert: bool):
        w = int(self.width)
        h = int(self.height)
        if x0 + w <= 0 or x0 >= 72 or y0 + h <= 0 or y0 >= 40:
            return # sprite completely outside screen

        w_start = 0 if x0 >= 0 else 0 - x0     # which vertical scanlines will be rendered
        w_end = w if x0 + w <= 72 else 72 - x0
        
        y_start = y0 // 8 # byte offset on vertical scanline
        h_start = 0 if y_start >= 0 else 0 - y_start # first byte to render
        y_off = y_start if y_start >= 0 else 0
        shift = y0 % 8    #  required bit shift
        h_end = (h + shift + 7) // 8 # last byte to render + 1
        if y_start + h_end > 5:
            h_end = 5 - y_start

        scr = ptr8(thumby.display.display.buffer)
        for dx in range(w_start, w_end):
            sp = x0 + dx + y_off * 72
            b_long = uint(self.bitmap[dx]) << shift
            m_long = uint(self.mask[dx]) << shift
            b_long >>= (8 * h_start)
            m_long >>= (8 * h_start)
            if invert:
                b_long ^= -1
                for b in range(h_start, h_end):
                    scr[sp] |= m_long # operates on lsb
                    scr[sp] &= b_long
                    m_long >>= 8
                    b_long >>= 8
                    sp += 72
            else:
                m_long ^= -1
                for b in range(h_start, h_end):
                    scr[sp] &= m_long # operates on lsb
                    scr[sp] |= b_long
                    m_long >>= 8
                    b_long >>= 8
                    sp += 72
